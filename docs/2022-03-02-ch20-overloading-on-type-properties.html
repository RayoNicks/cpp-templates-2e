
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Chapter 20 Overloading on Type Properties Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="2022-03-03-ch21-templates-and-inheritance.html" />
    
    
    <link rel="prev" href="2022-03-01-ch19-implementing-traits.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="2021-12-15-ch1-function-templates.html">
            
                <a href="2021-12-15-ch1-function-templates.html">
            
                    
                    Chapter 1 Funtion Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="2021-12-20-ch2-class-templates.html">
            
                <a href="2021-12-20-ch2-class-templates.html">
            
                    
                    Chapter 2 Class Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="2021-12-20-ch3-nontype-template-parameters.html">
            
                <a href="2021-12-20-ch3-nontype-template-parameters.html">
            
                    
                    Chapter 3 Nontype Template Parameters
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="2021-12-20-ch4-variadic-templates.html">
            
                <a href="2021-12-20-ch4-variadic-templates.html">
            
                    
                    Chapter 4 Variadic Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="2021-12-30-ch5-tricky-basics.html">
            
                <a href="2021-12-30-ch5-tricky-basics.html">
            
                    
                    Chapter 5 Tricky Basics
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="2022-01-04-ch6-move-semantics-and-enable-if.html">
            
                <a href="2022-01-04-ch6-move-semantics-and-enable-if.html">
            
                    
                    Chapter 6 Move Semantics and enable_if<>
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="2022-01-05-ch7-by-value-or-by-reference.html">
            
                <a href="2022-01-05-ch7-by-value-or-by-reference.html">
            
                    
                    Chapter 7 By Value or by Reference?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="2022-01-06-ch8-compile-time-programming.html">
            
                <a href="2022-01-06-ch8-compile-time-programming.html">
            
                    
                    Chapter 8 Compile-Time Programming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="2022-01-06-ch9-using-templates-in-practice.html">
            
                <a href="2022-01-06-ch9-using-templates-in-practice.html">
            
                    
                    Chapter 9 Using Templates in Practice
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="2022-01-07-ch10-basic-template-terminology.html">
            
                <a href="2022-01-07-ch10-basic-template-terminology.html">
            
                    
                    Chapter 10 Basic Template Terminology
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="2022-01-08-ch11-generic-libraries.html">
            
                <a href="2022-01-08-ch11-generic-libraries.html">
            
                    
                    Chapter 11 Generic Libraries
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="2022-01-12-ch12-fundamentals-in-depth.html">
            
                <a href="2022-01-12-ch12-fundamentals-in-depth.html">
            
                    
                    Chapter 12 Fundamentals in Depth
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="2022-01-27-ch13-names-in-templates.html">
            
                <a href="2022-01-27-ch13-names-in-templates.html">
            
                    
                    Chapter 13 Names in Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="2022-02-07-ch14-instantiation.html">
            
                <a href="2022-02-07-ch14-instantiation.html">
            
                    
                    Chapter 14 Instantiation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="2022-02-15-ch15-template-argument-deduction.html">
            
                <a href="2022-02-15-ch15-template-argument-deduction.html">
            
                    
                    Chapter 15 Template Argument Deduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="2022-02-17-ch16-specialization-and-overloading.html">
            
                <a href="2022-02-17-ch16-specialization-and-overloading.html">
            
                    
                    Chapter 16 Specialization and Overloading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="2022-02-22-ch17-future-directions.html">
            
                <a href="2022-02-22-ch17-future-directions.html">
            
                    
                    Chapter 17 Future Directions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="2022-02-23-ch18-the-polymorphic-power-of-templates.html">
            
                <a href="2022-02-23-ch18-the-polymorphic-power-of-templates.html">
            
                    
                    Chapter 18 The Polymorphic Power of Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="2022-03-01-ch19-implementing-traits.html">
            
                <a href="2022-03-01-ch19-implementing-traits.html">
            
                    
                    Chapter 19 Implementing Traits
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.21" data-path="2022-03-02-ch20-overloading-on-type-properties.html">
            
                <a href="2022-03-02-ch20-overloading-on-type-properties.html">
            
                    
                    Chapter 20 Overloading on Type Properties
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="2022-03-03-ch21-templates-and-inheritance.html">
            
                <a href="2022-03-03-ch21-templates-and-inheritance.html">
            
                    
                    Chapter 21 Templates and Inheritance
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="2022-03-05-ch22-bridging-static-and-dynamic-polymorphism.html">
            
                <a href="2022-03-05-ch22-bridging-static-and-dynamic-polymorphism.html">
            
                    
                    Chapter 22 Bridging Static and Dynamic Polymorphism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="2022-03-05-ch23-metaprogramming.html">
            
                <a href="2022-03-05-ch23-metaprogramming.html">
            
                    
                    Chapter 23 Metaprogramming
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.25" data-path="2022-03-06-ch24-typelists.html">
            
                <a href="2022-03-06-ch24-typelists.html">
            
                    
                    Chapter 24 Typelists
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.26" data-path="2022-03-07-ch25-tuples.html">
            
                <a href="2022-03-07-ch25-tuples.html">
            
                    
                    Chapter 25 Tuples
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.27" data-path="2022-03-08-ch26-discriminated-unions.html">
            
                <a href="2022-03-08-ch26-discriminated-unions.html">
            
                    
                    Chapter 26 Discriminated Unions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.28" data-path="2022-03-09-ch27-expression-templates.html">
            
                <a href="2022-03-09-ch27-expression-templates.html">
            
                    
                    Chapter 27 Expression Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.29" data-path="2022-03-09-ch28-debugging-templates.html">
            
                <a href="2022-03-09-ch28-debugging-templates.html">
            
                    
                    Chapter 28 Debugging Templates
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.30" data-path="2022-01-05-appB-value-categories.html">
            
                <a href="2022-01-05-appB-value-categories.html">
            
                    
                    Appendix B Value Categories
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.31" data-path="2022-03-02-appC-overload-resolution.html">
            
                <a href="2022-03-02-appC-overload-resolution.html">
            
                    
                    Appendix C Overload Resolution
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Chapter 20 Overloading on Type Properties</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="20-&#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x91CD;&#x8F7D;">20 &#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x91CD;&#x8F7D;</h1>
<h2 id="201-&#x7B97;&#x6CD5;&#x7279;&#x5316;">20.1 &#x7B97;&#x6CD5;&#x7279;&#x5316;</h2>
<p>&#x7B97;&#x6CD5;&#x7279;&#x5316;&#xFF08;algorithm specialization&#xFF09;&#x662F;&#x4E3A;&#x67D0;&#x79CD;&#x7279;&#x5B9A;&#x7C7B;&#x578B;&#x8BBE;&#x8BA1;&#x7684;&#x7B97;&#x6CD5;&#xFF0C;&#x901A;&#x5E38;&#x6BD4;&#x6CDB;&#x578B;&#x7B97;&#x6CD5;&#x6027;&#x80FD;&#x9AD8;&#x3002;&#x5728;&#x5B9A;&#x4E49;&#x4E86;&#x7279;&#x5316;&#x7684;&#x7B97;&#x6CD5;&#x540E;&#xFF0C;&#x4E00;&#x822C;&#x53EA;&#x9700;&#x501F;&#x52A9;&#x91CD;&#x8F7D;&#x89E3;&#x6790;&#x89C4;&#x5219;&#x4FBF;&#x53EF;&#x4EE5;&#x81EA;&#x52A8;&#x8C03;&#x7528;&#x7279;&#x5316;&#x7684;&#x7B97;&#x6CD5;&#xFF0C;&#x4F8B;&#x5982;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; x, T&amp; y)</span>
</span>{
    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(x)</span></span>;
    x = y;
    y = tmp;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Array&lt;T&gt;&amp; x, Array&lt;T&gt;&amp; y)</span>
</span>{
    swap(x.ptr, y.ptr);
    swap(x.len, y.len);
}
</code></pre>
<p>&#x4F46;&#x4E5F;&#x4E0D;&#x662F;&#x6240;&#x6709;&#x7684;&#x7279;&#x5316;&#x7B97;&#x6CD5;&#x90FD;&#x53EF;&#x4EE5;&#x7B80;&#x5355;&#x7684;&#x8F6C;&#x6362;&#x4E3A;&#x51FD;&#x6570;&#x6A21;&#x677F;&#xFF0C;&#x4F8B;&#x5982;&#x4E0B;&#x9762;&#x7684;&#x8FED;&#x4EE3;&#x5668;&#x524D;&#x8FDB;&#x7684;&#x4F8B;&#x5B50;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> InputIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIter</span><span class="hljs-params">(InputIterator&amp; x, Distance n)</span>
</span>{
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// linear time</span>
        ++x;
        --n;
    }
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> RandomAccessIterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIter</span><span class="hljs-params">(RandomAccessIterator&amp; x, Distance n)</span> </span>{
    x += n; <span class="hljs-comment">// constant time</span>
}
</code></pre>
<p>&#x4E24;&#x4E2A;<code>advanceIter()</code>&#x6A21;&#x677F;&#x53EA;&#x6709;&#x6A21;&#x677F;&#x53C2;&#x6570;&#x540D;&#x5B57;&#x4E0D;&#x540C;&#xFF0C;&#x7F16;&#x8BD1;&#x5668;&#x5C06;&#x65E0;&#x6CD5;&#x89E3;&#x6790;&#x3002;</p>
<h2 id="Tag-Dispatching">20.2 &#x901A;&#x8FC7;&#x6807;&#x7B7E;&#x5B9E;&#x73B0;&#x51FD;&#x6570;&#x6A21;&#x677F;&#x7684;&#x5206;&#x53D1; </h2>
<p>&#x5F15;&#x5165;&#x8FED;&#x4EE3;&#x5668;&#x6807;&#x7B7E;&#x540E;&#x5C31;&#x53EF;&#x4EE5;&#x6B63;&#x786E;&#x89E3;&#x6790;&#x4E86;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIterImpl</span><span class="hljs-params">(Iterator&amp; x, Distance n, <span class="hljs-built_in">std</span>::input_iterator_tag)</span>
</span>{
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// linear time</span>
        ++x;
        --n;
    }
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIterImpl</span><span class="hljs-params">(Iterator&amp; x, Distance n, <span class="hljs-built_in">std</span>::random_access_iterator_tag)</span> </span>{
    x += n; <span class="hljs-comment">// constant time</span>
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIter</span><span class="hljs-params">(Iterator&amp; x, Distance n)</span>
</span>{
    advanceIterImpl(x, n, <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category());
}
</code></pre>
<p>&#x6807;&#x51C6;&#x5E93;&#x4E2D;&#x8FED;&#x4EE3;&#x5668;&#x7684;&#x5206;&#x7C7B;&#x5982;&#x4E0B;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span> {
    <span class="hljs-keyword">struct</span> input_iterator_tag { };
    <span class="hljs-keyword">struct</span> output_iterator_tag { };
    <span class="hljs-keyword">struct</span> forward_iterator_tag : <span class="hljs-keyword">public</span> input_iterator_tag { };
    <span class="hljs-keyword">struct</span> bidirectional_iterator_tag : <span class="hljs-keyword">public</span> forward_iterator_tag { };
    <span class="hljs-keyword">struct</span> random_access_iterator_tag : <span class="hljs-keyword">public</span> bidirectional_iterator_tag { };
}
</code></pre>
<h2 id="203-&#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x51FD;&#x6570;&#x6A21;&#x677F;">20.3 &#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x51FD;&#x6570;&#x6A21;&#x677F;</h2>
<p>&#x901A;&#x8FC7;<code>EnableIf&lt;&gt;</code>&#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x51FD;&#x6570;&#x6A21;&#x677F;&#xFF0C;&#x539F;&#x7406;&#x4F9D;&#x7136;&#x662F;SFINAE&#x89C4;&#x5219;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/enableif.hpp</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;
<span class="hljs-keyword">struct</span> EnableIfT {
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">struct</span> EnableIfT&lt;<span class="hljs-literal">true</span>, T&gt; {
    <span class="hljs-keyword">using</span> Type = T;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> Cond, <span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">void</span>&gt;
<span class="hljs-keyword">using</span> EnableIf = <span class="hljs-keyword">typename</span> EnableIfT&lt;Cond, T&gt;::Type;
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> IsRandomAccessIterator =
    IsConvertible&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category,
                    <span class="hljs-built_in">std</span>::random_access_iterator_tag&gt;;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;
advanceIter(Iterator&amp; x, Distance n) {
    x += n; <span class="hljs-comment">// constant time</span>
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
EnableIf&lt;!IsRandomAccessIterator&lt;Iterator&gt;&gt;
advanceIter(Iterator&amp; x, Distance n)
{
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// linear time</span>
        ++x;
        --n;
    }
}
</code></pre>
<p>&#x6CE8;&#x610F;&#x540C;&#x65F6;&#x4E5F;&#x8981;&#x7981;&#x7528;&#x5176;&#x5B83;&#x91CD;&#x8F7D;&#x51FD;&#x6570;&#xFF0C;&#x5426;&#x5219;&#x4F1A;&#x5BFC;&#x81F4;&#x6A21;&#x7CCA;&#x8C03;&#x7528;&#x3002;</p>
<h3 id="2031-&#x591A;&#x6761;&#x4EF6;&#x4E0B;&#x7684;&#x7B97;&#x6CD5;&#x7279;&#x5316;">20.3.1 &#x591A;&#x6761;&#x4EF6;&#x4E0B;&#x7684;&#x7B97;&#x6CD5;&#x7279;&#x5316;</h3>
<p>&#x6709;&#x4E9B;&#x8FED;&#x4EE3;&#x5668;&#x8FD8;&#x53EF;&#x4EE5;&#x540E;&#x9000;&#xFF0C;&#x6240;&#x4EE5;&#x73B0;&#x5728;&#x7684;&#x9700;&#x6C42;&#x53D8;&#x6210;&#x4E86;&#xFF1A;</p>
<ul>
<li>&#x5BF9;&#x4E8E;&#x968F;&#x673A;&#x8BBF;&#x95EE;&#x8FED;&#x4EE3;&#x5668;&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x5E38;&#x91CF;&#x65F6;&#x95F4;&#x5185;&#x524D;&#x8FDB;&#x548C;&#x540E;&#x9000;</li>
<li>&#x5BF9;&#x4E8E;&#x53CC;&#x5411;&#x8FED;&#x4EE3;&#x5668;&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x7EBF;&#x6027;&#x65F6;&#x95F4;&#x5185;&#x524D;&#x8FDB;&#x548C;&#x540E;&#x9000;</li>
<li>&#x5BF9;&#x4E8E;&#x8F93;&#x5165;&#x8FED;&#x4EE3;&#x5668;&#xFF0C;&#x53EA;&#x80FD;&#x5728;&#x7EBF;&#x6027;&#x65F6;&#x95F4;&#x5185;&#x524D;&#x8FDB;</li>
</ul>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/advance2.hpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span>

<span class="hljs-comment">// implementation for random access iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
EnableIf&lt;IsRandomAccessIterator&lt;Iterator&gt;&gt;
advanceIter(Iterator&amp; x, Distance n) {
    x += n; <span class="hljs-comment">// constant time</span>
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> IsBidirectionalIterator =
    IsConvertible&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category,
                    <span class="hljs-built_in">std</span>::bidirectional_iterator_tag&gt;;

<span class="hljs-comment">// implementation for bidirectional iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
EnableIf&lt;IsBidirectionalIterator&lt;Iterator&gt; &amp;&amp; !IsRandomAccessIterator&lt;Iterator&gt;&gt;
advanceIter(Iterator&amp; x, Distance n) {
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">for</span> ( ; n &gt; <span class="hljs-number">0</span>; ++x, --n) {  <span class="hljs-comment">// linear time</span>
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> ( ; n &lt; <span class="hljs-number">0</span>; --x, ++n) {  <span class="hljs-comment">// linear time</span>
        }
    }
}

<span class="hljs-comment">// implementation for all other iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
EnableIf&lt;!IsBidirectionalIterator&lt;Iterator&gt;&gt;
advanceIter(Iterator&amp; x, Distance n) {
    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;advanceIter(): invalid iterator category for negative n&quot;</span>;
    }
    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) { <span class="hljs-comment">// linear time</span>
        ++x;
        --n;
    }
}
</code></pre>
<h3 id="Where-Does-the-EnableIf-Go">20.3.2 &#x5C06;EnableIf&#x4F5C;&#x4E3A;&#x9ED8;&#x8BA4;&#x6A21;&#x677F;&#x53C2;&#x6570; </h3>
<p><code>EnableIf&lt;&gt;</code>&#x4E00;&#x822C;&#x5199;&#x5728;&#x51FD;&#x6570;&#x6A21;&#x677F;&#x7684;&#x8FD4;&#x56DE;&#x7C7B;&#x578B;&#x5904;&#xFF0C;&#x5BF9;&#x4E8E;&#x6CA1;&#x6709;&#x8FD4;&#x56DE;&#x7C7B;&#x578B;&#x7684;&#x51FD;&#x6570;&#xFF0C;<code>EnableIf&lt;&gt;</code>&#x53EF;&#x4EE5;&#x4F5C;&#x4E3A;&#x9ED8;&#x8BA4;&#x7684;&#x6A21;&#x677F;&#x5B9E;&#x53C2;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/container1.hpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iterator&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;enableif.hpp&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;isconvertible.hpp&quot;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> IsInputIterator =
    IsConvertible&lt;
                    <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category,
                    <span class="hljs-built_in">std</span>::input_iterator_tag&gt;;

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> Container {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// construct from an input iterator sequence:</span>
        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,
                    <span class="hljs-keyword">typename</span> = EnableIf&lt;IsInputIterator&lt;Iterator&gt;&gt;&gt;
        Container(Iterator first, Iterator last);

        <span class="hljs-comment">// convert to a container so long as the value types are convertible:</span>
        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> = EnableIf&lt;IsConvertible&lt;T, U&gt;&gt;&gt;
        <span class="hljs-keyword">operator</span> Container&lt;U&gt;() <span class="hljs-keyword">const</span>;
};
</code></pre>
<h3 id="2033-&#x7F16;&#x8BD1;&#x65F6;if">20.3.3 &#x7F16;&#x8BD1;&#x65F6;if</h3>
<p>&#x501F;&#x52A9;C++17&#x7684;&#x7F16;&#x8BD1;&#x65F6;<code>if</code>&#x53EF;&#x4EE5;&#x907F;&#x514D;&#x4F7F;&#x7528;<code>EnableIf&lt;&gt;</code>&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/advance3.hpp</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> Distance&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">advanceIter</span><span class="hljs-params">(Iterator&amp; x, Distance n)</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsRandomAccessIterator&lt;Iterator&gt;)</span> </span>{
        <span class="hljs-comment">// implementation for random access iterators:</span>
        x += n;                         <span class="hljs-comment">// constant time</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span><span class="hljs-params">(IsBidirectionalIterator&lt;Iterator&gt;)</span> </span>{
        <span class="hljs-comment">// implementation for bidirectional iterators:</span>
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">for</span> ( ; n &gt; <span class="hljs-number">0</span>; ++x, --n) {  <span class="hljs-comment">// linear time for positive n</span>
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> ( ; n &lt; <span class="hljs-number">0</span>; --x, ++n) {  <span class="hljs-comment">// linear time for negative n</span>
            }
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// implementation for all other iterators that are at least input iterators:</span>
        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;advanceIter(): invalid iterator category for negative n&quot;</span>;
        }
        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {                 <span class="hljs-comment">// linear time for positive n only</span>
            ++x;
            --n;
        }
    }
}
</code></pre>
<h3 id="2034-concepts">20.3.4 Concepts</h3>
<p>&#x4F7F;&#x7528;concept&#x53EF;&#x4EE5;&#x6700;&#x7B80;&#x5355;&#x7684;&#x5B9E;&#x73B0;&#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x6A21;&#x677F;&#xFF0C;&#x4F46;&#x53EF;&#x60DC;&#x7684;&#x662F;&#x8FD8;&#x6CA1;&#x6709;&#x652F;&#x6301;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/container4.hpp</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> Container {
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// construct from an input iterator sequence:</span>
        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        requires IsInputIterator&lt;Iterator&gt;
        Container(Iterator first, Iterator last);

        <span class="hljs-comment">// construct from a random access iterator sequence:</span>
        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        requires IsRandomAccessIterator&lt;Iterator&gt;
        Container(Iterator first, Iterator last);

        <span class="hljs-comment">// convert to a container so long as the value types are convertible:</span>
        <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
        requires IsConvertible&lt;T, U&gt;
        <span class="hljs-keyword">operator</span> Container&lt;U&gt;() <span class="hljs-keyword">const</span>;
};
</code></pre>
<h2 id="204-&#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x7C7B;&#x6A21;&#x677F;&#x7279;&#x5316;">20.4 &#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x7C7B;&#x6A21;&#x677F;&#x7279;&#x5316;</h2>
<h3 id="2041-&#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x7279;&#x5316;&#x7684;&#x7C7B;&#x6A21;&#x677F;">20.4.1 &#x542F;&#x7528;&#x548C;&#x7981;&#x7528;&#x7279;&#x5316;&#x7684;&#x7C7B;&#x6A21;&#x677F;</h3>
<p>&#x548C;<a href="#Where-Does-the-EnableIf-Go">20.3.2</a>&#x4E00;&#x6837;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5F15;&#x5165;&#x9ED8;&#x8BA4;&#x6A21;&#x677F;&#x53C2;&#x6570;&#x6765;&#x5339;&#x914D;&#x7279;&#x5316;&#x7684;&#x7C7B;&#x6A21;&#x677F;&#xFF0C;&#x672C;&#x8282;&#x4E2D;&#x4EE5;&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;&#x5B57;&#x5178;&#x4E3A;&#x4F8B;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> = <span class="hljs-keyword">void</span>&gt;
<span class="hljs-keyword">class</span> Dictionary
{
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">vector</span>&lt;pair&lt;Key <span class="hljs-keyword">const</span>, Value&gt;&gt; data;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-comment">// subscripted access to the data:</span>
        value&amp; <span class="hljs-keyword">operator</span>[](Key <span class="hljs-keyword">const</span>&amp; key)
        {
            <span class="hljs-comment">// search for the element with this key:</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; element : data) {
                <span class="hljs-keyword">if</span> (element.first == key) {
                    <span class="hljs-keyword">return</span> element.second;
                }
            }

            <span class="hljs-comment">// there is no element with this key; add one</span>
            data.push_back(pair&lt;Key <span class="hljs-keyword">const</span>, Value&gt;(key, Value()));
            <span class="hljs-keyword">return</span> data.back().second;
        }
        <span class="hljs-comment">// ...</span>
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value&gt;
<span class="hljs-keyword">class</span> Dictionary&lt;Key, Value, EnableIf&lt;HasLess&lt;Key&gt; &amp;&amp; !HasHash&lt;Key&gt;&gt;&gt;
{
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">map</span>&lt;Key, Value&gt; data;
    <span class="hljs-keyword">public</span>:
        value&amp; <span class="hljs-keyword">operator</span>[](Key <span class="hljs-keyword">const</span>&amp; key) {
            <span class="hljs-keyword">return</span> data[key];
        }
        <span class="hljs-comment">// ...</span>
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value&gt;
<span class="hljs-keyword">class</span> Dictionary&lt;Key, Value, EnableIf&lt;HasHash&lt;Key&gt;&gt;&gt;
{
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">unordered_map</span>&lt;Key, Value&gt; data;
    <span class="hljs-keyword">public</span>:
        value&amp; <span class="hljs-keyword">operator</span>[](Key <span class="hljs-keyword">const</span>&amp; key) {
            <span class="hljs-keyword">return</span> data[key];
        }
        <span class="hljs-comment">// ...</span>
};
</code></pre>
<h3 id="2042-&#x901A;&#x8FC7;&#x6807;&#x7B7E;&#x5339;&#x914D;&#x7C7B;&#x6A21;&#x677F;">20.4.2 &#x901A;&#x8FC7;&#x6807;&#x7B7E;&#x5339;&#x914D;&#x7C7B;&#x6A21;&#x677F;</h3>
<p><code>advanceIter()</code>&#x4E5F;&#x53EF;&#x4EE5;&#x501F;&#x52A9;&#x7C7B;&#x6A21;&#x677F;&#x5B9E;&#x73B0;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// primary template (intentionally undefined):</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator,
            <span class="hljs-keyword">typename</span> Tag =
                BestMatchInSet&lt;<span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category,
                                <span class="hljs-built_in">std</span>::input_iterator_tag,
                                <span class="hljs-built_in">std</span>::bidirectional_iterator_tag,
                                <span class="hljs-built_in">std</span>::random_access_iterator_tag&gt;&gt;
<span class="hljs-keyword">class</span> Advance;

<span class="hljs-comment">// general, linear-time implementation for input iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">class</span> Advance&lt;Iterator, <span class="hljs-built_in">std</span>::input_iterator_tag&gt;
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">using</span> DifferenceType = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Iterator&amp; x, DifferenceType n)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {
                ++x;
                --n;
            }
        }
};

<span class="hljs-comment">// bidirectional, linear-time algorithm for bidirectional iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">class</span> Advance&lt;Iterator, <span class="hljs-built_in">std</span>::bidirectional_iterator_tag&gt;
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">using</span> DifferenceType = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Iterator&amp; x, DifferenceType n)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) {
                    ++x;
                    --n;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">while</span> (n &lt; <span class="hljs-number">0</span>) {
                    --x;
                    ++n;
                }
            }
        }
};

<span class="hljs-comment">// bidirectional, constant-time algorithm for random access iterators:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
<span class="hljs-keyword">class</span> Advance&lt;Iterator, <span class="hljs-built_in">std</span>::random_access_iterator_tag&gt;
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">using</span> DifferenceType = <span class="hljs-keyword">typename</span> <span class="hljs-built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(Iterator&amp; x, DifferenceType n)</span> <span class="hljs-keyword">const</span>
        </span>{
            x += n;
        }
}
</code></pre>
<p><code>BestMatchInSet&lt;&gt;</code>&#x7684;&#x529F;&#x80FD;&#x4E3A;&#x627E;&#x5230;&#x6700;&#x5339;&#x914D;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x8FD9;&#x53EF;&#x4EE5;&#x501F;&#x52A9;&#x51FD;&#x6570;&#x7684;&#x91CD;&#x8F7D;&#x673A;&#x5236;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// construct a set of match() overloads for the types in Types...:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Types&gt;
<span class="hljs-keyword">struct</span> MatchOverloads;

<span class="hljs-comment">// basis case: nothing matched:</span>
<span class="hljs-keyword">template</span>&lt;&gt;
<span class="hljs-keyword">struct</span> MatchOverloads&lt;&gt; {
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">match</span><span class="hljs-params">(...)</span></span>;
};

<span class="hljs-comment">// recursive case: introduce a new match() overload:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span>... Rest&gt;
<span class="hljs-keyword">struct</span> MatchOverloads&lt;T1, Rest...&gt; : <span class="hljs-keyword">public</span> MatchOverloads&lt;Rest...&gt; {
    <span class="hljs-function"><span class="hljs-keyword">static</span> T1 <span class="hljs-title">match</span><span class="hljs-params">(T1)</span></span>;                    <span class="hljs-comment">// introduce overload for T1</span>
    <span class="hljs-keyword">using</span> MatchOverloads&lt;Rest...&gt;::match;   <span class="hljs-comment">// collect overloads from bases</span>
};

<span class="hljs-comment">// find the best match for T in Types...:</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;
<span class="hljs-keyword">struct</span> BestMatchInSetT {
    <span class="hljs-keyword">using</span> Type = <span class="hljs-keyword">decltype</span>(MatchOverloads&lt;Types...&gt;::match(declval&lt;T&gt;()));
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Types&gt;
<span class="hljs-keyword">using</span> BestMatchInSet = <span class="hljs-keyword">typename</span> BestMatchInSetT&lt;T, Types...&gt;::Type;
</code></pre>
<p><code>MatchOverloads&lt;&gt;</code>&#x901A;&#x8FC7;&#x9012;&#x5F52;&#x7684;&#x65B9;&#x5F0F;&#x91CD;&#x8F7D;&#x4E86;&#x591A;&#x4E2A;<code>match()</code>&#xFF0C;&#x6BCF;&#x4E2A;&#x51FD;&#x6570;&#x63A5;&#x53D7;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x7684;&#x53C2;&#x6570;&#x3002;&#x5F53;&#x5728;<code>decltype</code>&#x5BF9;<code>match()</code>&#x8C03;&#x7528;&#x8FDB;&#x884C;&#x63A8;&#x5BFC;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x5B9E;&#x73B0;&#x6700;&#x4F73;&#x5339;&#x914D;&#x3002;&#x4E2A;&#x4EBA;&#x8BA4;&#x4E3A;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x8FC7;&#x7A0B;&#x5E94;&#x8BE5;&#x4E3A;&#xFF1A;</p>
<ol>
<li>&#x5B9E;&#x4F8B;&#x5316;<code>BestMatchInSet&lt;&gt;</code>&#x89E6;&#x53D1;&#x5B9E;&#x4F8B;&#x5316;<code>BestMatchInSetT&lt;&gt;</code></li>
<li>&#x5B9E;&#x4F8B;&#x5316;<code>BestMatchInSetT&lt;&gt;</code>&#x65F6;&#x4F1A;&#x68C0;&#x67E5;<code>Type</code>&#x7684;&#x5B9A;&#x4E49;&#xFF0C;&#x8FD9;&#x4F1A;&#x89E6;&#x53D1;<code>decltype</code>&#x4E2D;&#x7684;&#x63A8;&#x5BFC;&#xFF0C;&#x4ECE;&#x800C;&#x89E6;&#x53D1;&#x5B9E;&#x4F8B;&#x5316;<code>MatchOverloads&lt;Types...&gt;</code></li>
<li>&#x5B9E;&#x4F8B;&#x5316;<code>MatchOverloads&lt;T1, Rest...&gt;</code>&#x4F1A;&#x9012;&#x5F52;&#x5B9E;&#x4F8B;&#x5316;&#x57FA;&#x7C7B;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x6BCF;&#x4E2A;&#x57FA;&#x7C7B;&#x4E2D;&#x5B9A;&#x4E49;<code>match()</code>&#xFF0C;&#x5E76;&#x5728;&#x6D3E;&#x751F;&#x7C7B;&#x4E2D;&#x62C9;&#x53D6;&#x57FA;&#x7C7B;&#x7684;<code>match()</code></li>
<li>&#x56DE;&#x5230;&#x7B2C;2&#x6B65;&#xFF0C;<code>decltype</code>&#x4E2D;&#x7684;&#x63A8;&#x5BFC;&#x4F1A;&#x6839;&#x636E;&#x91CD;&#x8F7D;&#x89E3;&#x6790;&#x89C4;&#x5219;&#x9009;&#x62E9;&#x6700;&#x5339;&#x914D;&#x7684;<code>match()</code>&#xFF0C;&#x6700;&#x7EC8;&#x63A8;&#x5BFC;&#x51FA;<code>BestMatchInSet&lt;&gt;::Type</code>&#x7684;&#x7C7B;&#x578B;</li>
<li>&#x56DE;&#x5230;&#x7B2C;1&#x6B65;&#xFF0C;&#x5F15;&#x7528;<code>BestMatchInSetT&lt;T, Types...&gt;::Type</code>&#x5F97;&#x5230;&#x6700;&#x7EC8;&#x7ED3;&#x679C;</li>
</ol>
<p>&#x4E66;&#x4E2D;&#x5173;&#x4E8E;&#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x7684;&#x89E3;&#x91CA;&#xFF1A;</p>
<blockquote>
<p>The MatchOverloads template uses recursive inheritance to declare a match() function with each type in the input set of Types.</p>
<p>Each instantiation of the recursive MatchOverloads partial specialization introduces a new match() function for the next type in the list. It then employs a using declaration to pull in the match() function(s) defined in its base class, which handles the remaining types in the list. When applied recursively, the result is a complete set of match() overloads corresponding to the given types, each of which returns its parameter type. </p>
<p>The BestMatchInSetT template then passes a T object to this set of overloaded match() functions and produces the return type of the selected (best) match() function. If none of the functions matches, the void returning basis case (which uses an ellipsis to capture any argument) indicates failure.</p>
<p>To summarize, BestMatchInSetT translates a function-overloading result into a trait and makes it relatively easy to use tag dispatching to select among class template partial specializations.</p>
</blockquote>
<h2 id="205-&#x53EF;&#x5B89;&#x5168;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x6A21;&#x677F;">20.5 &#x53EF;&#x5B89;&#x5168;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x6A21;&#x677F;</h2>
<p>&#x5982;&#x679C;&#x5C06;&#x6BCF;&#x4E00;&#x4E2A;&#x6A21;&#x677F;&#x53C2;&#x6570;&#x90FD;&#x4F7F;&#x7528;<code>EnableIf</code>&#x8FDB;&#x884C;&#x9650;&#x5236;&#xFF0C;&#x5219;&#x5F53;&#x6A21;&#x677F;&#x4EE3;&#x6362;&#x5931;&#x8D25;&#x65F6;SFINAE&#x89C4;&#x5219;&#x4F1A;&#x8D77;&#x4F5C;&#x7528;&#xFF0C;&#x4E0D;&#x4F1A;&#x5BFC;&#x81F4;&#x7F16;&#x8BD1;&#x5931;&#x8D25;&#xFF0C;&#x8FD9;&#x6837;&#x7684;&#x6A21;&#x677F;&#x79F0;&#x4E3A;&#x53EF;&#x5B89;&#x5168;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#x6A21;&#x677F;&#xFF08;instantiation-safe templates&#xFF09;&#x3002;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x4E0D;&#x662F;&#x53EF;&#x5B89;&#x5168;&#x5B9E;&#x4F8B;&#x5316;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x65E0;&#x6CD5;&#x4FDD;&#x8BC1;&#x7C7B;&#x578B;<code>T</code>&#x652F;&#x6301;<code>&lt;</code>&#x8FD0;&#x7B97;&#x7B26;&#xFF0C;&#x4E5F;&#x65E0;&#x6CD5;&#x4FDD;&#x8BC1;&#x7ED3;&#x679C;&#x53EF;&#x4EE5;&#x8F6C;&#x6362;&#x4E3A;<code>bool</code>&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function">T <span class="hljs-keyword">const</span>&amp; <span class="hljs-title">min</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
    <span class="hljs-keyword">if</span> (y &lt; x) {
        <span class="hljs-keyword">return</span> y;
    }
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>&#x4E3A;&#x4E86;&#x4FDD;&#x8BC1;&#x7C7B;&#x578B;<code>T</code>&#x652F;&#x6301;<code>&lt;</code>&#x8FD0;&#x7B97;&#x7B26;&#xFF0C;&#x9700;&#x8981;&#x5B9E;&#x73B0;<code>LessResultT&lt;&gt;</code>&#xFF1A;</p>
<pre><code class="lang-cpp">// typeoverload/lessresult.hpp
#include &lt;utility&gt;      // for declval()
#include &lt;type_traits&gt;  // for true_type and false_type

template&lt;typename T1, typename T2&gt;
class HasLess {
    template&lt;typename T&gt; struct Identity;
    template&lt;typename U1, typename U2&gt; static std::true_type
        test(Identity&lt;decltype(std::declval&lt;U1&gt;() &lt; std::declval&lt;U2&gt;())&gt;*);
    template&lt;typename U1, typename U2&gt; static std::false_type
        test(...);
    public:
        static constexpr bool value = decltype(test&lt;T1, T2&gt;(nullptr))::value;
};

template&lt;typename T1, typename T2, bool HasLess&gt;
class LessResultImpl {
    public:
        using Type = decltype(std::declval&lt;T1&gt;() &lt; std::declval&lt;T2&gt;());
};

template&lt;typename T1, typename T2&gt;
class LessResultImpl&lt;T1, T2, false&gt; {
};

template&lt;typename T1, typename T2&gt;
class LessResultT
    : public LessResultImpl&lt;T1, T2, HasLess&lt;T1, T2&gt;::value&gt; {
};

template&lt;typename T1, typename T2&gt;
using LessResult = typename LessResultT&lt;T1, T2&gt;::Type;
</code></pre>
<p>&#x5E76;&#x6539;&#x8FDB;<code>min()</code>&#x7684;&#x5B9A;&#x4E49;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/min2.hpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;isconvertible.hpp&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;lessresult.hpp&quot;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
EnableIf&lt;IsConvertible&lt;LessResult&lt;T <span class="hljs-keyword">const</span>&amp;, T <span class="hljs-keyword">const</span>&amp;&gt;, <span class="hljs-keyword">bool</span>&gt;, T <span class="hljs-keyword">const</span>&amp;&gt;
min(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)
{
    <span class="hljs-keyword">if</span> (y &lt; x) {
        <span class="hljs-keyword">return</span> y;
    }
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<p>&#x6D4B;&#x8BD5;&#x4EE3;&#x7801;&#xFF1A;</p>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/min.cpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;min.hpp&quot;</span></span>

<span class="hljs-keyword">struct</span> X1 { };
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (X1 <span class="hljs-keyword">const</span>&amp;, X1 <span class="hljs-keyword">const</span>&amp;) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

<span class="hljs-keyword">struct</span> X2 { };
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(X2, X2) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

<span class="hljs-keyword">struct</span> X3 { };
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(X3&amp;, X3&amp;) { <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }

<span class="hljs-keyword">struct</span> X4 { };

<span class="hljs-keyword">struct</span> BoolConvertible {
    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; } <span class="hljs-comment">// implicit conversion to bool</span>
};
<span class="hljs-keyword">struct</span> X5 { };
BoolConvertible <span class="hljs-keyword">operator</span>&lt; (X5 <span class="hljs-keyword">const</span>&amp;, X5 <span class="hljs-keyword">const</span>&amp;)
{
    <span class="hljs-keyword">return</span> BoolConvertible();
}

<span class="hljs-keyword">struct</span> NotBoolConvertible { <span class="hljs-comment">// no conversion to bool</span>
};
<span class="hljs-keyword">struct</span> X6 { };
NotBoolConvertible <span class="hljs-keyword">operator</span>&lt; (X6 <span class="hljs-keyword">const</span>&amp;, X6 <span class="hljs-keyword">const</span>&amp;)
{
    <span class="hljs-keyword">return</span> NotBoolConvertible();
}

<span class="hljs-keyword">struct</span> BoolLike {
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; } <span class="hljs-comment">// explicit conversion to bool</span>
};
<span class="hljs-keyword">struct</span> X7 { };
BoolLike <span class="hljs-keyword">operator</span>&lt; (X7 <span class="hljs-keyword">const</span>&amp;, X7 <span class="hljs-keyword">const</span>&amp;) { <span class="hljs-keyword">return</span> BoolLike(); }

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    min(X1(), X1());    <span class="hljs-comment">// X1 can be passed to min()</span>
    min(X2(), X2());    <span class="hljs-comment">// X2 can be passed to min()</span>
    min(X3(), X3());    <span class="hljs-comment">// ERROR: X3 cannot be passed to min()</span>
    min(X4(), X4());    <span class="hljs-comment">// ERROR: X4 cannot be passed to min()</span>
    min(X5(), X5());    <span class="hljs-comment">// X5 can be passed to min()</span>
    min(X6(), X6());    <span class="hljs-comment">// ERROR: X6 cannot be passed to min()</span>
    min(X7(), X7());    <span class="hljs-comment">// UNEXPECTED ERROR: X7 cannot be passed to min()</span>
}
</code></pre>
<p><code>X3</code>&#x62A5;&#x9519;&#x7684;&#x539F;&#x56E0;&#x5728;&#x4E8E;<code>&lt;</code>&#x8FD0;&#x7B97;&#x7B26;&#x4E0D;&#x80FD;&#x6BD4;&#x8F83;&#x4E24;&#x4E2A;&#x4E34;&#x65F6;&#x5BF9;&#x8C61;&#xFF0C;<code>X4</code>&#x62A5;&#x9519;&#x7684;&#x539F;&#x56E0;&#x5728;&#x4E8E;&#x6CA1;&#x6709;&#x5339;&#x914D;&#x7684;<code>&lt;</code>&#x8FD0;&#x7B97;&#x7B26;&#xFF0C;<code>X6</code>&#x62A5;&#x9519;&#x7684;&#x539F;&#x56E0;&#x5728;&#x4E8E;<code>NotBoolConvertible</code>&#x4E0D;&#x80FD;&#x9690;&#x5F0F;&#x8F6C;&#x6362;&#x4E3A;<code>bool</code>&#x7C7B;&#x578B;&#x3002;</p>
<p>&#x6700;&#x6709;&#x610F;&#x601D;&#x7684;&#x662F;<code>X7</code>&#x3002;<code>explicit</code>&#x4FEE;&#x9970;&#x7684;&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#x53EA;&#x5728;&#x6761;&#x4EF6;&#x8868;&#x8FBE;&#x5F0F;&#x3001;&#x903B;&#x8F91;&#x8FD0;&#x7B97;&#x7B26;&#x548C;&#x6761;&#x4EF6;&#x8FD0;&#x7B97;&#x7B26;<code>? :</code>&#x4E2D;&#x53EF;&#x4EE5;&#x4F5C;&#x4E3A;&#x9690;&#x5F0F;&#x8F6C;&#x6362;&#xFF0C;&#x79F0;&#x4E3A;&#x7279;&#x5B9A;&#x8BED;&#x5883;&#x4E0B;&#x7684;&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#xFF08;contextually converted&#xFF09;&#xFF0C;&#x800C;<code>IsConvertible&lt;&gt;</code>&#x662F;&#x501F;&#x52A9;<code>decltype</code>&#x4E2D;&#x7684;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x5224;&#x65AD;&#x662F;&#x5426;&#x53EF;&#x4EE5;&#x8FDB;&#x884C;&#x8F6C;&#x6362;&#x7684;&#xFF0C;&#x6240;&#x4EE5;<code>X7</code>&#x4E2D;&#x7684;&#x7C7B;&#x578B;&#x8F6C;&#x6362;&#x4E0D;&#x8D77;&#x4F5C;&#x7528;&#xFF0C;&#x4E3A;&#x6B64;&#x9700;&#x8981;&#x5F15;&#x5165;<code>IsContextualBoolT&lt;&gt;</code>&#xFF1A;</p>
<pre><code class="lang-cpp">// typeoverload/iscontextualbool.hpp
#include &lt;utility&gt;      // for declval()
#include &lt;type_traits&gt;  // for true_type and false_type

template&lt;typename T&gt;
class IsContextualBoolT {
    private:
        template&lt;typename T&gt; struct Identity;
        template&lt;typename U&gt; static std::true_type
            test(Identity&lt;decltype(declval&lt;U&gt;() ? 0 : 1)&gt;*);
        template&lt;typename U&gt; static std::false_type
            test(...);
    public:
        static constexpr bool value = decltype(test&lt;T&gt;(nullptr))::value;
};
template&lt;typename T&gt;
constexpr bool IsContextualBool = IsContextualBoolT&lt;T&gt;::value;
</code></pre>
<pre><code class="lang-cpp"><span class="hljs-comment">// typeoverload/min3.hpp</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;iscontextualbool.hpp&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">&quot;lessresult.hpp&quot;</span></span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
EnableIf&lt;IsContextualBool&lt;LessResult&lt;T <span class="hljs-keyword">const</span>&amp;, T <span class="hljs-keyword">const</span>&amp;&gt;&gt;, T <span class="hljs-keyword">const</span>&amp;&gt;
min(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)
{
    <span class="hljs-keyword">if</span> (y &lt; x) {
        <span class="hljs-keyword">return</span> y;
    }
    <span class="hljs-keyword">return</span> x;
}
</code></pre>
<h2 id="206-&#x6807;&#x51C6;&#x5E93;&#x4E2D;&#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x91CD;&#x8F7D;">20.6 &#x6807;&#x51C6;&#x5E93;&#x4E2D;&#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x91CD;&#x8F7D;</h2>
<p>&#x9664;&#x4E86;<a href="#Tag-Dispatching">20.2</a>&#x4E2D;&#x5DF2;&#x7ECF;&#x63D0;&#x5230;&#x7684;&#x8FED;&#x4EE3;&#x5668;&#x5206;&#x7C7B;&#x5916;&#xFF0C;&#x6807;&#x51C6;&#x5E93;&#x4E2D;&#x57FA;&#x4E8E;&#x7C7B;&#x578B;&#x5C5E;&#x6027;&#x7684;&#x91CD;&#x8F7D;&#x8FD8;&#x5305;&#x62EC;&#xFF1A;</p>
<ul>
<li>&#x4EE5;&#x67D0;&#x4E9B;&#x7C7B;&#x578B;&#x8C03;&#x7528;<code>std::copy</code>&#x65F6;&#x6700;&#x7EC8;&#x4F1A;&#x8C03;&#x7528;<code>std::memcpy</code>&#x6216;&#x8005;<code>std::memmove</code></li>
<li>&#x4EE5;&#x67D0;&#x4E9B;&#x7C7B;&#x578B;&#x8C03;&#x7528;<code>std::fill</code>&#x65F6;&#x6700;&#x7EC8;&#x4F1A;&#x8C03;&#x7528;<code>std::memset</code></li>
<li>&#x907F;&#x514D;&#x8C03;&#x7528;&#x5E73;&#x51E1;&#x7684;&#x6790;&#x6784;&#x51FD;&#x6570;</li>
</ul>
<p>&#x300A;STL&#x6E90;&#x7801;&#x5256;&#x6790;&#x300B;&#x4E00;&#x4E66;&#x4E2D;&#x4ECB;&#x7ECD;&#x4E86;&#x5927;&#x91CF;&#x6709;&#x5173;&#x8FD9;&#x90E8;&#x5206;&#x7684;&#x5185;&#x5BB9;&#x3002;</p>
<h2 id="207-&#x540E;&#x8BB0;">20.7 &#x540E;&#x8BB0;</h2>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="2022-03-01-ch19-implementing-traits.html" class="navigation navigation-prev " aria-label="Previous page: Chapter 19 Implementing Traits">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="2022-03-03-ch21-templates-and-inheritance.html" class="navigation navigation-next " aria-label="Next page: Chapter 21 Templates and Inheritance">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Chapter 20 Overloading on Type Properties","level":"1.21","depth":1,"next":{"title":"Chapter 21 Templates and Inheritance","level":"1.22","depth":1,"path":"2022-03-03-ch21-templates-and-inheritance.md","ref":"2022-03-03-ch21-templates-and-inheritance.md","articles":[]},"previous":{"title":"Chapter 19 Implementing Traits","level":"1.20","depth":1,"path":"2022-03-01-ch19-implementing-traits.md","ref":"2022-03-01-ch19-implementing-traits.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"2022-03-02-ch20-overloading-on-type-properties.md","mtime":"2022-11-13T05:00:16.191Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2022-11-13T05:01:04.198Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

